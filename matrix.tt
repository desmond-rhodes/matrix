/* public */

template <typename T>
template <typename ...U>
matrix<T>::matrix(size_t r, size_t c, U... l)
	: matrix(r, c, {l...}) {}

template <typename T> size_t matrix<T>::row() const { return _row; };
template <typename T> size_t matrix<T>::col() const { return _col; };

template <typename T>
T& matrix<T>::operator()(size_t r, size_t c) { return _data[r*_col+c]; }

template <typename T>
T const& matrix<T>::operator()(size_t r, size_t c) const { return _data[r*_col+c]; }

/* private */

template <typename T>
matrix<T>::matrix(size_t r, size_t c, std::initializer_list<T> l)
	: _data(r*c), _row {r}, _col {c}
{
	auto it {l.begin()};
	for (auto& i : _data)
		if (it == l.end())
			break;
		else
			i = *it++;
}

/* free */

template <typename T>
bool operator==(matrix<T> const& m, matrix<T> const& n) {
	if (m.row() != n.row() || m.col() != n.col())
		return false;
	for (size_t i {0}; i < m.row(); ++i)
		for (size_t j {0}; j < m.col(); ++j)
			if (m(i, j) != n(i, j))
				return false;
	return true;
}

template <typename T>
bool operator!=(matrix<T> const& m, matrix<T> const& n) { return !(m == n); }

template <typename T>
matrix<T> operator*(matrix<T> const& m, matrix<T> const& n) {
	matrix<T> o(m.row(), n.col());
	for (size_t i {0}; i < o.row(); ++i)
		for (size_t j {0}; j < o.col(); ++j) {
			o(i, j) = 0;
			for (size_t k {0}; k < m.col(); ++k)
				o(i, j) += m(i, k) * n(k, j);
		}
	return o;
}

template <typename T>
matrix<T>& operator*=(matrix<T>& m, matrix<T> const& n) {
	m = m * n;
	return m;
}
